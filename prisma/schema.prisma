// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

enum Role {
  USER
  CREATOR
  ADMIN
}

// Visibility for posts - currently all posts are PUBLIC
enum Visibility {
  PUBLIC
  UNLISTED
  PRIVATE
}
// enum Plan {
//   FREE
//   PRO
//   PRO_PLUS
// }

// Type of post content
enum PostType {
  PHOTO      // Standard photo post
  BLOG       // Blog post (already in use)
  REPOST     // Reposted content from another user
}

enum BlogStatus {
  DRAFT
  PUBLISHED
}

// enum Provider {
//   STRIPE
// }

model User {
  id           String @id @default(uuid()) @db.Uuid
  email        String @unique
  passwordHash String
  role         Role   @default(USER)

    // ✅ ADD THESE TWO LINES
  emailVerified DateTime?  // null = not verified, date = when they verified
  isActive      Boolean @default(true)  // for account lockouts later

    // ✅ ADD THESE LINES
  failedLoginAttempts Int      @default(0)
  lockedUntil         DateTime?

  profile        Profile?
  onboardingDone Boolean  @default(false)

// Photo and post relationships - user can create photos and posts
  photos        Photo[]
  posts         Post[]


  // Social interactions - user can like and repost content
  likes         Like[]
  reposts       Repost[]


  blogPosts     BlogPost[]

  // collections   HubCollection[]
  // subscriptions Subscription[]
  // auditLogs     AuditLog[]      @relation("AuditActor")

  // Follow system - users can follow and be followed by others
  following     Follow[]        @relation("UserFollowing")
  followers     Follow[]        @relation("UserFollowers")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Profile {
  id          String  @id @db.Uuid
  user        User    @relation(fields: [id], references: [id]) // 1 to 1, pk = fk
  displayName String?
  username    String  @unique
  bio         String?
  location    String?
  avatarUrl   String?
  website     String?
  socials     Json?
  isCreator   Boolean @default(false)
  // plan        Plan     @default(FREE)
  stats       Json? // denormalised counters, for example postCount, likeCount
}

/// Stores one time tokens for things like email verification
/// or password reset. Used by NextAuth and custom flows.
model VerificationToken {
  /// Usually an email address or user identifier
  identifier String

  /// The actual random token that gets emailed
  token String @unique

  /// When this token expires and stops being valid
  expires DateTime

  @@unique([identifier, token])
}


// Photo model - stores uploaded images with metadata
// Each photo can be part of a post

model Photo {
  id         String        @id @default(uuid()) @db.Uuid
  user       User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String        @db.Uuid

  url        String        // Full size image URL from Cloudinary
  thumbUrl   String?       // Thumbnail URL for feed performance
  caption    String?       // Optional caption (can be added later)
  location   String?       // Optional location (can be added later)
  exif       Json?         // Camera/photo metadata
  tags       String[]      @db.Text // Searchable tags (can be added later)
  visibility Visibility    @default(PUBLIC) // All posts public for now

  posts      Post[]        // A photo can be in multiple posts (original + reposts)

  createdAt  DateTime      @default(now())

    @@index([userId, createdAt])
  @@index([visibility, createdAt])
}



// Post model - represents content in the feed
// Posts are created automatically when photos are uploaded
model Post {
  id              String     @id @default(uuid()) @db.Uuid
  user            User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String     @db.Uuid

  photo           Photo?     @relation(fields: [photoId], references: [id], onDelete: Cascade)
  photoId         String?    @db.Uuid

  caption         String?    // Optional post caption
  type            PostType   @default(PHOTO) // Type of post

  // Repost functionality - tracks original post when reposting
  originalPost    Post?      @relation("RepostOf", fields: [originalPostId], references: [id], onDelete: Cascade)
  originalPostId  String?    @db.Uuid
  reposts         Post[]     @relation("RepostOf") // Posts that reposted this one

  // Social interactions on this post
  likes           Like[]
  repostActions   Repost[]   // Track who reposted

  createdAt       DateTime   @default(now())

  @@index([userId, createdAt])
  @@index([type, createdAt])
  @@index([photoId])
  @@index([originalPostId])
}

// Like model - tracks user likes on posts
// Unique constraint ensures user can only like a post once
model Like {
  id        String   @id @default(uuid()) @db.Uuid
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String   @db.Uuid
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    String   @db.Uuid
  createdAt DateTime @default(now())

  @@unique([userId, postId]) // User can only like a post once
   @@index([postId, createdAt])
  @@index([userId])
}

// Repost model - tracks user reposts
// Different from Post.reposts - this tracks the action, Post tracks the new post created
model Repost {
  id        String   @id @default(uuid()) @db.Uuid
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String   @db.Uuid
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    String   @db.Uuid
  createdAt DateTime @default(now())

  @@unique([userId, postId]) // User can only repost a post once
    @@index([postId, createdAt])
  @@index([userId])
}

// Follow model - tracks follow relationships between users
// Composite primary key ensures uniqueness
model Follow {
  followerId String @db.Uuid
  followingId String @db.Uuid

  follower   User   @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)
  following  User   @relation("UserFollowers", fields: [followingId], references: [id], onDelete: Cascade)

  createdAt  DateTime @default(now())

  @@id([followerId, followingId]) // Composite pk, forces uniqueness - user can only follow another user once
    @@index([followerId, createdAt])
  @@index([followingId, createdAt])
}

model BlogPost {
  id          String      @id @default(uuid()) @db.Uuid
  author      User        @relation(fields: [userId], references: [id])
  userId      String      @db.Uuid

  slug        String      @unique
  title       String
  excerpt     String?
  coverUrl    String?
  content     String      // markdown or rich text
  tags        String[]    @db.Text
  publishedAt DateTime?
  status      BlogStatus  @default(DRAFT)

  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

    @@index([status, publishedAt])
  @@index([userId, status])
  @@index([slug])
}

// model HubCollection {
//   id            String           @id @default(uuid()) @db.Uuid
//   user          User             @relation(fields: [userId], references: [id])
//   userId        String           @db.Uuid

//   title         String
//   description   String?
//   coverUrl      String?
//   featuredLabel String?

//   photos        CollectionPhoto[]

//   createdAt     DateTime         @default(now())
// }

// model CollectionPhoto {
//   id           String        @id @default(uuid()) @db.Uuid
//   collection   HubCollection @relation(fields: [collectionId], references: [id])
//   collectionId String        @db.Uuid
//   photo        Photo         @relation(fields: [photoId], references: [id])
//   photoId      String        @db.Uuid
//   sortOrder    Int           @default(0)
// }

// model Subscription {
//   id                 String    @id @default(uuid()) @db.Uuid
//   user               User      @relation(fields: [userId], references: [id])
//   userId             String    @db.Uuid

//   provider           Provider  @default(STRIPE)
//   status             String
//   plan               Plan
//   currentPeriodEnd   DateTime?
//   metadata           Json?

//   createdAt          DateTime  @default(now())
//   updatedAt          DateTime  @updatedAt
// }

// model AuditLog {
//   id         String   @id @default(uuid()) @db.Uuid
//   actor      User?    @relation("AuditActor", fields: [actorId], references: [id])
//   actorId    String?  @db.Uuid

//   action     String
//   targetType String
//   targetId   String
//   payload    Json?
//   createdAt  DateTime @default(now())
// }
